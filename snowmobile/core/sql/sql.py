"""
:mod:`SQL` contains utility methods to generate & execute common SQL commands.

note:
    *   The :attr:`auto_run` attribute defaults to `True`, meaning that the
        generated sql will execute when a method is called; if set to `False`
        the method will return the sql as a string without executing.
    *   The :class:`SQL` object is primarily interacted with as a
        pre-instantiated attribute of :class:`Connector`; in these instances
        users can fetch the generated sql as a string either by:
            1.  Providing *run=False* to any method called; this will override
                all behavior set by the current value of :attr:`auto_run`.
            2.  Setting the :attr:`auto_run` attribute to `False` on an existing
                instance of :class:`SQL`, which will replicate the behavior of
                `(1)` without needing to provide *run=False* to each method
                called on that instance. This is illustrated in lines **10**,
                **13**, and **16** of the below example:

                .. literalinclude:: /examples/mod_sql/set_auto_run.py
                   :language: python
                   :lineno-start: 1
                   :emphasize-lines: 10, 13, 16


"""
from pathlib import Path
from typing import List, Union, Optional, Dict

import pandas as pd

from snowmobile.core.utils.parsing import up, strip
from ._map_information_schema import MAP_INFORMATION_SCHEMA as INFO


class SQL:
    """SQL class for generation & execution of common sql commands.

    Intended to be interacted with as an attribute of :class:`snowmobile.Connect`.

    note:
        *   All arguments except for :attr:`sn` are optional.
        *   The benefit of setting the other attributes on an instance of :class:`SQL`
            is to (optionally) avoid passing the same information to multiple methods
            when generating a variety of statements around the same object.

    Attributes:
        sn (snowmobile.Connect):
            :class:`snowmobile.Connect` for sql execution and connection information.
        obj_name (str):
            Object name to use in generated sql (e.g. 'some_table_name')
        obj_type (str):
            Object type to use in generated sql (e.g. 'table')
        obj_schema (str):
            Schema to use when dot-prefixing sql; defaults to the schema with which the
            :attr:`sn` is connected to.
        auto_run (bool):
            Indicates whether to automatically execute the sql generated by a given
            method; defaults to *True*

    """

    def __init__(
        self,
        sn=None,
        obj_name: Optional[str] = None,
        obj_type: Optional[str] = None,
        obj_schema: Optional[str] = None,
        auto_run: Optional[bool] = True,
    ):
        """Initializes a :class:`snowmobile.SQL` object."""
        self.sn = sn
        self.obj_name: str = obj_name
        self.obj_type: str = obj_type or "table"
        self.obj_schema = obj_schema or sn.cfg.connection.current.schema_name
        self.auto_run: bool = auto_run

    def info_schema_tables(
        self,
        table: str = None,
        schema: str = None,
        fields: List[str] = None,
        restrictions: Dict[str, str] = None,
        order_by: List[Union[str, int]] = None,
        all_schemas: bool = False,
        run: bool = None,
    ) -> Union[str, pd.DataFrame]:
        """Query ``information_schema.tables`` for a given table or view.

        Args:
            table (str):
                Table or view name.
            schema (str):
                Table or view schema; defaults to the schema with which the
                :attr:`SQL.sn` is connected to at the time the method is called.
            fields (List[str]):
                List of fields to include in returned results (e.g.
                ['table_name', 'table_type', 'last_altered'])
            restrictions (List[str]):
                List of conditionals typed as literal components of a `where`
                clause (e.g.
                ["table_type = 'base table'", 'last_altered::date = current_date()']
                ).
            order_by (List[str]):
                List of fields or their ordinal positions to order the results by.
            all_schemas (bool):
                Include tables/views from all schemas; defaults to `False`.
            run (bool):
                Determines whether to run the generated sql or not; defaults to `None`
                which will reference the current value of the :attr:`auto_run` attribute
                which defaults to `True`.

        Returns (Union[str, pd.DataFrame]):
            Either:
                1.  The results of the query as a :class:`pandas.DataFrame`, or
                2.  The generated query as a :class:`str` of sql.

        """
        # fmt: off
        try:
            table = self._validate(
                val=(table or self.obj_name), nm='table', attr_nm='obj_schema'
            )
            schema = self._validate(
                val=(schema or self.obj_schema), nm='schema', attr_nm='obj_schema'
            )
        except ValueError as e:
            raise e
        # fmt: off
        base_restrictions = {
            'lower(table_name)': f"'{table.lower()}'",
        }
        if not all_schemas:
            base_restrictions['lower(table_schema)'] = f"'{schema.lower()}'",
        restrictions = {
            **base_restrictions,
            **(restrictions or dict())
        }
        sql = self._info_schema_generic(
            obj_typ="table",
            fields=fields,
            restrictions=restrictions,
            order_by=order_by,
        )
        return self.sn.query(sql=sql) if self._run(run) else sql

    def info_schema_columns(
        self,
        table: str = None,
        schema: str = None,
        fields: List = None,
        restrictions: Dict = None,
        order_by: List = None,
        all_schemas: bool = False,
        run: bool = None,
    ) -> Union[str, pd.DataFrame]:
        """Query ``information_schema.columns`` for a given table or view.

        Args:
            table (str):
                Table or view name.
            schema (str):
                Table or view schema; defaults to the schema with which the
                :attr:`SQL.sn` is connected to at the time the method is called.
            fields (List[str]):
                List of fields to include in returned results (e.g.
                ['ordinal_position', 'column_name', 'data_type'])
            restrictions (List[str]):
                List of conditionals typed as literal components of a `where`
                clause (e.g.["regexp_count(lower(column_name), 'tmstmp') = 0"]).
            order_by (List[str]):
                List of fields or their ordinal positions to order the results by.
            all_schemas (bool):
                Include tables/views from all schemas; defaults to `False`.
            run (bool):
                Determines whether to run the generated sql or not; defaults to `None`
                which will reference the current value of the :attr:`auto_run` attribute
                which defaults to `True`.

        Returns (Union[str, pd.DataFrame]):
            Either:
                1.  The results of the query as a :class:`pandas.DataFrame`, or
                2.  The generated query as a :class:`str` of sql.

        """
        # fmt: off
        try:
            table = self._validate(
                val=(table or self.obj_name), nm='table', attr_nm='obj_schema'
            )
            schema = self._validate(
                val=(schema or self.obj_schema), nm='schema', attr_nm='obj_schema'
            )
        except ValueError as e:
            raise e
        # fmt: off
        base_restrictions = {
            'lower(table_name)': f"'{table.lower()}'",
        }
        if not all_schemas:
            base_restrictions['lower(table_schema)'] = f"'{schema.lower()}'",
        restrictions = {
            **base_restrictions,
            **(restrictions or dict())
        }
        sql = self._info_schema_generic(
            obj_typ="column",
            fields=fields,
            restrictions=restrictions,
            order_by=order_by,
        )
        return self.sn.query(sql=sql) if self._run(run) else sql

    def table_last_altered(
        self,
        schema: str = None,
        table: str = None,
        run: bool = None,
    ) -> Union[str, pd.DataFrame]:
        """Last altered timestamp for a table or view.

        Args:
            table (str):
                 Name of table; defaults to :attr:`SQL.obj_name`.
            schema (str):
                Schema of table; defaults to the schema of the session
                associated with the current :attr:`SQL.sn` attribute.
            run (bool):
                Indicates whether to execute generated sql or return as string;
                default is `True`.

        Returns (Union[str, pd.DataFrame]):
            Either:
                1.  The results of the query as a :class:`pandas.DataFrame`, or
                2.  The generated query as a :class:`str` of sql.

        """
        # fmt: off
        try:
            table = self._validate(
                val=(table or self.obj_name), nm='table', attr_nm='obj_name'
            )
            schema = self._validate(
                val=(schema or self.obj_schema), nm='schema', attr_nm='obj_schema'
            )
        except ValueError as e:
            raise e
        # fmt: off
        _sql = self.info_schema_tables(
            table=table,
            schema=schema,
            fields=["table_name", "table_schema", "last_altered"],
        )
        _sql = strip(_sql)
        sql = strip(_sql)
        return self.sn.query(sql=sql) if self._run(run) else sql

    def create_stage(
        self, stage_name: str, file_format: str, run: bool = None, replace: bool = False
    ) -> Union[str, pd.DataFrame]:
        """Create a staging table.

        Args:
            stage_name (str):
                Name of stage to create.
            file_format (str):
                Name of file format to specify for stage.
            run (bool):
                Indicates whether to execute generated sql or return as string;
                default is `True`.
            replace (bool):
                Indicates whether to replace an existing stage if pre-existing;
                default is `False`.

        Returns (Union[str, pd.DataFrame]):
            Either:
                1.  The results of the query as a :class:`pandas.DataFrame`, or
                2.  The generated query as a :class:`str` of sql.

        """
        create = self._create(replace=replace)
        _sql = f"{create} stage {stage_name} file_format = {file_format};"
        sql = strip(_sql)
        return self.sn.query(sql=sql) if self._run(run) else sql

    def drop(
        self,
        obj_type: str = None,
        obj_name: str = None,
        obj_schema: str = None,
        run: bool = None,
    ) -> Union[str, pd.DataFrame]:
        """Drop a ``Snowflake`` object.

        Args:
            obj_type (str):
                Type of object to drop (e.g. 'table', 'view', 'file-format', ..).
            obj_schema (str):
                Schema of object to drop; defaults to :attr:`SQL.obj_schema`.
            obj_name (str):
                Name of object to drop (e.g. 'some_table_name')
            run (bool):
                Indicates whether to execute generated sql or return as string;
                default is `True`.

        Returns (Union[str, pd.DataFrame]):
            Either:
                1.  The results of the query as a :class:`pandas.DataFrame`, or
                2.  The generated query as a :class:`str` of sql.

        """
        # fmt: off
        try:
            obj_type = self._validate(
                val=(obj_type or self.obj_type), nm='obj_type', attr_nm='obj_type'
            )
            obj_schema = self._validate(
                val=(obj_schema or self.obj_schema), nm='obj_schema', attr_nm='obj_schema'
            )
            obj_name = self._validate(
                val=(obj_name or self.obj_name), nm='obj_name', attr_nm='obj_name'
            )
        except ValueError as e:
            raise e
        # fmt: on
        _sql = f"drop {obj_type} if exists {up(obj_schema)}.{up(obj_name)}"
        sql = strip(_sql)
        return self.sn.query(sql=sql) if self._run(run) else sql

    def clone(
        self,
        obj_name: str = None,
        obj_schema: str = None,
        obj_type: str = None,
        target_name: str = None,
        target_schema: str = None,
        run: bool = None,
        replace: bool = False,
    ) -> Union[str, pd.DataFrame]:
        """Clone a ``Snowflake`` object.

        Warnings:
            *   Make sure to read `Snowflake's documentation
                <https://docs.snowflake.com/en/sql-reference/sql/create-clone.html>`_
                for restrictions and considerations when cloning objects.

        Note:
            *   **At least one of the** ``target_name`` **or**
                ``target_schema`` **arguments must be provided**.
            *   The defaults for the target object are constructed such that
                users can **either**:
                    1.  Clone objects to *other* schemas that inherit the
                        source object's *name* without specifying a
                        ``target_name``, **or**
                    2.  Clone objects in the *current* schema that inherit the
                        source object's *schema* without specifying a
                        ``target_schema``.
            *   An assertion error will be raised raised if neither argument
                is specified as *this would result in a command to clone an
                object and store it in an object that has the same name &
                schema as the object being cloned*.

        Args:
            obj_name (str):
                Name of object to clone (e.g. 'some_table_name'); defaults to
                the value of :attr:`SQL.obj_name`.
            obj_schema (str):
                Schema of object to clone; defaults to the schema of the session
                associated with the current :attr:`SQL.sn` attribute.
            obj_type (str):
                Type of object to clone (e.g. 'table', 'view', 'file-format');
                defaults to `table`.
            target_name (str):
                Cloned object's name; default is to mirror ``obj_name``.
            target_schema (str):
                Cloned object's schema; default is to mirror ``obj_schema``.
            run (bool):
                Indicates whether to execute generated sql or return as string;
                default is `True`.
            replace (bool):
                Indicates whether to replace an existing stage if pre-existing;
                default is `False`.

        Returns (Union[str, pd.DataFrame]):
            Either:
                1.  The results of the query as a :class:`pandas.DataFrame`, or
                2.  The generated query as a :class:`str` of sql.

        """
        # fmt: off
        try:
            obj_type = self._validate(
                val=(obj_type or self.obj_type), nm='obj_type', attr_nm='obj_type'
            )
            obj_schema = self._validate(
                val=(obj_schema or self.obj_schema), nm='obj_schema', attr_nm='obj_schema'
            )
            obj_name = self._validate(
                val=(obj_name or self.obj_name), nm='obj_name', attr_nm='obj_name'
            )

            target_schema = target_schema or obj_schema
            target_name = target_name or obj_name
            if not target_schema or target_name:
                raise ValueError(
                    "At least one of 'target_schema' or 'target_name` must be provided"
                    "to the .clone() method."
                )
            if obj_name == target_name and obj_schema == target_schema:
                raise ValueError(
                    f"Target object name & schema mirrors source object name/schema. "
                    f"Please provide a different `target_name` or `target_schema`."
                )
        except ValueError as e:
            raise e
        # fmt: on
        create = self._create(replace=replace)
        _sql = (
            f"{create} {obj_type} {up(target_schema)}.{up(target_name)} "
            f"clone {up(obj_schema)}.{up(obj_name)}"
        )
        sql = strip(_sql)
        return self.sn.query(sql=sql) if self._run(run) else sql

    def put_file_from_stage(
        self, file_location: Union[Path, str], stage_name: str, run: bool = None,
        options: Dict = None, ignore_defaults: bool = False

    ) -> Union[str, pd.DataFrame]:
        """Generates a 'put' command into a staging table from a local file.

        Args:
            file_location (Union[Path, str]):
                Path to local data file as a :class:`pathlib.Path` or string.
            stage_name (str):
                Name of the staging table to load into.
            run (bool):
                Indicates whether to execute generated sql or return as string;
                default is `True`.
            options (dict):
                Optional arguments to add to `put` statement in addition to
                the values specified in the ``loading-defaults.put`` section
                of **snowmobile.toml**.
            ignore_defaults (bool):
                Option to ignore the values specified in **snowmobile.toml**;
                defaults to `False`.

        Returns (Union[str, pd.DataFrame]):
            Either:
                1.  The results of the query as a :class:`pandas.DataFrame`, or
                2.  The generated query as a :class:`str` of sql.

        """
        # fmt: off
        file_location = Path(str(file_location))
        statement = [f"put file://{file_location.as_posix()} @{stage_name}"]

        defaults = (
            self.sn.cfg.loading.put.dict(by_alias=False) if not ignore_defaults
            else dict()
        )
        options = {
            **defaults,
            **(options or dict()),
        }
        for k, v in options.items():
            statement.append(f"\t{k} = {v}")

        _sql = "\n".join(statement)
        sql = strip(_sql)

        return self.sn.query(sql=sql) if self._run(run) else sql
        # fmt: off

    def copy_into_table_from_stage(
        self, table: str, stage_name: str, run: bool = None,
        options: Dict = None, ignore_defaults: bool = False
    ) -> Union[str, pd.DataFrame]:
        """Generates a command to copy data into a table from a staging table.

        Args:
            table (str):
                Name of the table to load into.
            stage_name (str):
                Name of the staging table to load from.
            run (bool):
                Indicates whether to execute generated sql or return as string;
                default is `True`.
            options (dict):
                Optional arguments to add to `put` statement in addition to
                the values specified in the ``loading-defaults.put`` section
                of **snowmobile.toml**.
            ignore_defaults (bool):
                Option to ignore the values specified in **snowmobile.toml**;
                defaults to `False`.

        Returns (Union[str, pd.DataFrame]):
            Either:
                1.  The results of the query as a :class:`pandas.DataFrame`, or
                2.  The generated query as a :class:`str` of sql.

        """
        statement = [f"copy into {table} from @{stage_name}"]
        defaults = (
            self.sn.cfg.loading.copy_into.dict(by_alias=False) if not ignore_defaults
            else dict()
        )
        options = {
            **defaults,
            **(options or dict()),
        }
        for k, v in options.items():
            statement.append(f"\t{k} = {v}")
        _sql = "\n".join(statement)
        sql = strip(_sql)
        return self.sn.query(sql=sql) if self._run(run) else sql

    def show_file_formats(self, run: bool = None) -> Union[str, pd.DataFrame]:
        """Lists all file formats in the current schema.

        Args:
            run (bool):
                Indicates whether to execute generated sql or return as string;
                default is `True`.

        Returns (Union[str, pd.DataFrame]):
            Either:
                1.  The results of the query as a :class:`pandas.DataFrame`, or
                2.  The generated query as a :class:`str` of sql.

        """
        sql = f"show file formats"
        return self.sn.query(sql=sql) if self._run(run) else sql

    def ddl(
        self,
        obj_type: str = None,
        obj_schema: str = None,
        obj_name: str = None,
        run: bool = None,
    ) -> str:
        """Query the DDL for an in-warehouse object.

        Args:
            obj_name (str):
                Name of object; defaults to :attr:`SQL.obj_name`.
            obj_schema (str):
                Schema of object; defaults to the schema of the session
                associated with the current :attr:`SQL.sn` attribute.
            obj_type (str):
                Type of object to clone (e.g. 'table', 'view', 'file-format');
                defaults to `table` or the current value of :attr:`SQL.obj_type`
                if other than default.
            run (bool):
                Indicates whether to execute generated sql or return as string;
                default is `True`.

        Returns (str):
            Either:
                1.  The results of the query as a :class:`pandas.DataFrame`, or
                2.  The generated query as a :class:`str` of sql.

        """
        try:
            obj_type = self._validate(
                val=(obj_type or self.obj_type), nm='obj_type', attr_nm='obj_type'
            )
            obj_schema = self._validate(
                val=(obj_schema or self.obj_schema), nm='obj_schema', attr_nm='obj_schema'
            )
            obj_name = self._validate(
                val=(obj_name or self.obj_name), nm='obj_name', attr_nm='obj_name'
            )
        except ValueError as e:
            raise e
        _sql = f"select get_ddl('{obj_type}', '{up(obj_schema)}.{up(obj_name)}') as ddl"
        sql = strip(_sql)
        return self.sn.query(sql=sql).snowmobile.to_list(n=1) if self._run(run) else sql

    def table_sample(
        self,
        schema: str = None,
        table: str = None,
        n: int = None,
        run: bool = None,
    ) -> Union[str, pd.DataFrame]:
        """Select `n` sample records from a table.

        Args:
            table (str):
                 Name of object; defaults to :attr:`SQL.obj_name`.
            schema (str):
                Schema of object; defaults to the schema of the session
                associated with the current :attr:`SQL.sn` attribute.
            n (int):
                Number of records to return, implemented as a 'limit' clause
                in the query; defaults to 1.
            run (bool):
                Indicates whether to execute generated sql or return as string;
                default is `True`.

        Returns (Union[str, pd.DataFrame]):
            Either:
                1.  The results of the query as a :class:`pandas.DataFrame`, or
                2.  The generated query as a :class:`str` of sql.

        """
        # fmt: off
        try:
            schema = self._validate(
                val=(schema or self.obj_schema), nm='schema', attr_nm='obj_schema'
            )
            table = self._validate(
                val=(table or self.obj_name), nm='table', attr_nm='obj_name'
            )
        except ValueError as e:
            raise e
        # fmt: on
        _sql = f"""
select
    *
from {up(schema)}.{up(table)}
limit {n or 1}
        """
        sql = strip(_sql)
        return self.sn.query(sql=sql) if self._run(run) else sql

    def truncate(
        self,
        schema: str = None,
        table: str = None,
        run: bool = None
    ) -> Union[str, pd.DataFrame]:
        """Truncate a table.

        Args:
            table (str):
                 Name of table; defaults to :attr:`SQL.obj_name`.
            schema (str):
                Schema of table; defaults to the schema of the session
                associated with the current :attr:`SQL.sn` attribute.
            run (bool):
                Indicates whether to execute generated sql or return as string;
                default is `True`.

        Returns (Union[str, pd.DataFrame]):
            Either:
                1.  The results of the query as a :class:`pandas.DataFrame`, or
                2.  The generated query as a :class:`str` of sql.

        """
        # fmt: off
        try:
            schema = self._validate(
                val=(schema or self.obj_schema), nm='schema', attr_nm='obj_schema'
            )
            name = self._validate(
                val=(table or self.obj_name), nm='table', attr_nm='obj_name'
            )
        except ValueError as e:
            raise e
        # fmt: on
        _sql = f"truncate table {up(schema)}.{up(name)}"
        sql = strip(_sql)
        return self.sn.query(sql=sql) if self._run(run) else sql

    def current(self, obj_typ: str, run: bool = None):
        """Generic implementation of 'select current' for session-based objects.

        Args:
            obj_typ (str):
                Type of object to retrieve information for (schema, session, ..).
            run (bool):
                Indicates whether to execute generated sql or return as string;
                default is `True`.

        Returns (Union[str, pd.DataFrame]):
            Either:
                1.  The results of the query as a :class:`pandas.DataFrame`, or
                2.  The generated query as a :class:`str` of sql.

        """
        _sql = f"select current_{obj_typ}()"
        sql = strip(_sql)
        return self.sn.query(sql=sql) if self._run(run) else sql

    def current_session(self, run: bool = None) -> Union[str, pd.DataFrame]:
        """Select the current session."""
        return self.current(obj_typ="session", run=run)

    def current_schema(self, run: bool = None) -> Union[str, pd.DataFrame]:
        """Select the current schema."""
        return self.current(obj_typ="schema", run=run)

    def current_database(self, run: bool = None) -> Union[str, pd.DataFrame]:
        """Select the current database."""
        return self.current(obj_typ="database", run=run)

    def current_warehouse(self, run: bool = None) -> Union[str, pd.DataFrame]:
        """Select the current warehouse."""
        return self.current(obj_typ="warehouse", run=run)

    def current_role(self, run: bool = None) -> Union[str, pd.DataFrame]:
        """Select the current role."""
        return self.current(obj_typ="role", run=run)

    def use(self, obj_typ: str, obj_nm: str, run: bool = None):
        """Generic implementation of 'use' command for in-warehouse objects.

        Args:
            obj_typ (str):
                Type of object to use (schema, warehouse, role, ..).
            obj_nm (str):
                Name of object to use (schema name, warehouse name, role name, ..).
            run (bool):
                Indicates whether to execute generated sql or return as string;
                default is `True`.

        Returns (Union[str, pd.DataFrame]):
            Either:
                1.  The results of the query as a :class:`pandas.DataFrame`, or
                2.  The generated query as a :class:`str` of sql.

        """
        _sql = f"use {obj_typ} {up(obj_nm)}"
        sql = strip(_sql)
        return self.sn.query(sql=sql) if self._run(run) else sql

    def use_schema(self, nm: str = None, run: bool = None) -> Union[str, pd.DataFrame]:
        """Use schema command."""
        return self.use(obj_typ="schema", obj_nm=nm, run=run)

    def use_database(
        self, nm: str = None, run: bool = None
    ) -> Union[str, pd.DataFrame]:
        """Use database command."""
        return self.use(obj_typ="database", obj_nm=nm, run=run)

    def use_warehouse(
        self, nm: str = None, run: bool = None
    ) -> Union[str, pd.DataFrame]:
        """Use warehouse command."""
        return self.use(obj_typ="warehouse", obj_nm=nm, run=run)

    def use_role(self, nm: str = None, run: bool = None) -> Union[str, pd.DataFrame]:
        """Use role command."""
        return self.use(obj_typ="role", obj_nm=nm, run=run)

    def columns(
        self,
        schema: str = None,
        table: str = None,
        from_info_schema: bool = False,
        run: bool = None,
    ) -> Union[str, List]:
        """Returns an ordered list of columns for a table or view.

        note:
            *   The default behavior of this method is to retrieve the columns
                for a table or view by selecting a single sample record
                from the table and extracting the column names directly off
                the returned :class:`pandas.DataFrame` due to the performance
                gains in selecting a sample record as opposed to querying the
                ``information_schema.columns``.
            *   This can be changed by passing `from_info_schema=False`.

        Args:
            table (str):
                 Name of table; defaults to :attr:`SQL.obj_name`.
            schema (str):
                Schema of table;  defaults to :attr:`SQL.obj_schema`.
            from_info_schema (bool):
                Indicates whether to retrieve columns via the
                ``information_schema.columns`` or by selecting a sample record
                from the table or view; defaults to `False`.
            run (bool):
                Indicates whether to execute generated sql or return as string;
                default is `True`.

        Returns (Union[str, List]):
            Either:
                1.  An ordered list of columns for the table or view, **or**
                2.  The query against the table or view as a :class:`str` of sql.

        """
        if from_info_schema:
            return self._columns_from_info_schema(
                table=table, schema=schema, run=run
            )
        else:
            return self._columns_from_sample(
                table=table, schema=schema, run=run
            )

    # noinspection PyBroadException
    def exists(self, table: str = None, schema: str = None) -> bool:
        """Checks the existence of a table or view.

        Args:
            table (str):
                Table or view name; defaults to :attr:`SQL.obj_name`.
            schema (str):
                Schema of table; defaults to the :attr:`SQL.obj_schema`.

        Returns (bool):
            Boolean indication of whether or not the table or view exists.

        """
        try:
            _ = self.table_sample(table=table, schema=schema,)
            return True
        except:
            return False

    def _columns_from_info_schema(
        self, table: str = None, schema: str = None, run: bool = None
    ) -> Union[str, List]:
        """Retrieves list of columns for a table or view **from information schema**.

        Args:
            table (str):
                Table or view name; defaults to :attr:`SQL.obj_name`.
            schema (str):
                Schema of table; defaults to the :attr:`SQL.obj_schema`.
            run (bool):
                Indicates whether to execute generated sql or return as string;
                default is `True`.

        Returns (Union[str, List]):
            Either:
                1.  An ordered list of columns for the table or view, **or**
                2.  The query against ``information_schema.columns`` as a
                    :class:`str` of sql.

        """
        _sql = self.info_schema_columns(
            table=table,
            schema=schema,
            fields=["ordinal_position", "column_name"],
            order_by=[1],
            run=False,
        )
        sql = strip(_sql)
        return (
            self.sn.query(sql).snowmobile.to_list(col_nm="column_name")
            if not run
            else sql
        )

    def _columns_from_sample(
        self, table: str = None, schema: str = None, run: bool = None
    ) -> Union[str, List]:
        """Retrieves a list of columns for a table or view from **sampling table**.

        Args:
            table (str):
                Table or view name; defaults to :attr:`SQL.obj_name`.
            schema (str):
                Schema of table; defaults to :attr:`SQL.obj_schema`.
            run (bool):
                Indicates whether to execute generated sql or return as string;
                default is `True`.

        Returns (Union[str, List]):
            Either:
                1.  An ordered list of columns for the table or view, **or**
                2.  The query against the table or view as a :class:`str` of sql.

        """
        _sql = self.table_sample(table=table, schema=schema, run=False, n=1)
        sql = strip(_sql)
        return list(
            self.sn.query(sql, lower=False).columns
        ) if self._run(run) else sql

    @staticmethod
    def _create(replace: bool = False):
        """Utility to generate 'create'/'create or replace' based on an argument."""
        return "create" if not replace else "create or replace"

    def _run(self, run: Union[bool, None]) -> bool:
        """Determines whether or not to execute a piece of sql.

        Used in all subsequent methods containing a `run` argument.

        Args:
            run (Union[bool, None]):
                The value from a method's `run` argument.

        Returns (bool):
            Boolean value indicating whether or not to execute the sql generated by
            the method to which the value of `run` was passed.

        note:
            *   The default value of `run` in all subsequent methods is ``None``.
            *   When any method of :class:`SQL` containing a `run` argument is called,
                the argument's value is passed to this method which returns either:
                    1.  The argument's value if it is a valid bool (i.e. a user-provided
                        value to the method), or
                    2.  The boolean representation of the current :attr:`auto_run`
                        attribute (`True` by default).

        """
        if isinstance(run, bool):
            return run
        else:
            return bool(self.auto_run)

    def _info_schema_generic(
        self,
        obj_typ: str,
        fields: List[str] = None,
        restrictions: Dict[str, str] = None,
        order_by: List = None,
    ) -> str:
        """Generic case of selecting from information schema tables/columns.
        """
        # fmt: off
        if obj_typ in INFO.values():
            obj_typ = {v: k for k, v in INFO.items()}[obj_typ]
        if obj_typ not in INFO.keys():
            raise ValueError(
                f"\nobj_typ='{obj_typ}' is not a supported object type for the"
                f" information_schema method called.\n"
                f"Supported objects are:\n\t[{','.join(INFO.keys())}]"
            )

        info_schema_loc = INFO[obj_typ]
        fields = self.fields(fields=fields)
        where = self.where(restrictions=restrictions)
        order_by = self.order_by(order_by=order_by)

        sql = (
            f"""
select 
    {fields}
from information_schema.{info_schema_loc}
{where}
{order_by}""".strip('\n').strip()
        )
        return strip(sql)
        # fmt: on

    @staticmethod
    def order_by(order_by: List[Union[int, str]]) -> str:
        """Utility to generate 'order by' clause."""
        if order_by:
            order_by_fields = ','.join([str(v) for v in order_by])
            return f"order_by {order_by_fields}"
        else:
            return str()

    @staticmethod
    def where(restrictions: Dict) -> str:
        """Utility to generate 'where' clause."""
        if restrictions:
            args = [
                f"{str(where_this)} = {str(equals_this)}"
                for where_this, equals_this in restrictions.items()
            ]
            args = "\n\tand ".join(args)
            return f"where\n\t{args}"
        else:
            return str()

    @staticmethod
    def fields(fields: List) -> str:
        """Utility to generate fields within a 'select' statement."""
        return '\n\t,'.join(fields or ['*'])

    @staticmethod
    def _validate(val: Union[str, int], nm: str, attr_nm: str = None) -> str:
        """Utility to validate the in-method value of an argument, including
        instances in which an unspecified argument falls back to an attribute
        value.

        Args:
            val (Union[str, int]:
                Value to validate.
            nm (str):
                Name of argument in method.
            attr_nm (str):
                Name of fallback attribute if applicable.
        """
        if not val:
            closing1 = (
                '.' if not attr_nm
                else f", nor is its fallback attribute '{attr_nm}'."
            )
            closing2 = (
                '.' if not attr_nm
                else f" or set the '{attr_nm}' attribute before calling the method."
            )
            raise ValueError(
                f"\nValue provided for '{nm}' is not valid{closing1}\n"
                f"Please provide a valid value for '{nm}'{closing2}"
            )
        return val

    def __getitem__(self, item):
        return vars(self)[item]

    def __setitem__(self, key, value):
        vars(self)[key] = value

    def __setattr__(self, key, value):
        vars(self)[key] = value

    def __str__(self) -> str:
        return f"snowmobile.SQL(creds='{self.sn.cfg.connection.creds}')"

    def __repr__(self) -> str:
        return f"snowmobile.SQL(creds='{self.sn.cfg.connection.creds}')"
